=== SHIFT/REDUCE PROBLEM ===
After adding some rules to the civic.y file it turned out that we had some shift/reduce errors.

Here are two actual lines from the Bison verbose output

   11 unexpr: unop expr .
   12 binexpr: expr . binop expr
   
The shift/reduce errors where caused by the following rule

expr: unexpr
    | binexpr
    ;
    
The two mentioned rules 'unexpr' and 'binexpr' are the names of a rule for unary expressions and for binary expressions repectivly.

This was fixed by combining the two rules into a single slightly more verbose rule, see below for a small portion of the actual solution.

expr: BRACKET_L expr BRACKET_R { $$ = $2; }
    | NOT expr          { $$ = TBmakeUnop( UO_not, $2); }
    | MINUS expr        { $$ = TBmakeUnop( UO_neg, $2); }
    | expr MINUS expr   { $$ = TBmakeBinop( BO_sub, $1, $3); }
    | expr PLUS expr    { $$ = TBmakeBinop( BO_add, $1, $3); }
    | expr STAR expr    { $$ = TBmakeBinop( BO_mul, $1, $3); }

Combined with left and right accosiativity rules for the operators it works as expected.


=== DO-WHILE vs WHILE ===
Currently we have two different AST nodes for the 'while' and the 'do-while' loop. These can easily be combined into a single 'while' node with an extra attribute indicating pre or post condition check in order to distinguish the two.

=== FOR loop vs WHILE loops ===
We can try to combine all the loops into a single AST node. For now we have not implemented this. Mainly because the differences between a for loop and the (do-)while loops.

=== CLEANER GRAMMER ===
We have rebuild the grammar file from scratch. Our grammar was very verbose. After rebuilding it is much move concise and clean. 

=== DANGLING ELSE PROBLEM ===
Introduced a 'bogus' token THEN
%nonassoc THEN
%nonassoc ELSE
And added '%prec THEN' to our grammar rule that handles the if-only case.

=== GIT BRANCHES ===
We have four branches
- master: for the core development
- LocalFunction: for local function related development
- Array: for single and multi dimensional arrays (we opted for developing multi dimensional arrays, it can always be downgraded to single dimensional array if we run out of time)
- Combined: an integration branch for integration of the other three branches (and whish should contain our compiler at the and of the course) 

=== TEST SUITE ===
After integrating the provided test suite we found some bugs in our grammar, for example the dangling-else problem. Within each branch the appropriate tests have been added.
Before every commit we should doe a 'make clean && make check' to ensure we only commit we behaving code.

=== HANDLING FORWARD FUNCTION DECLARATIONS ===
In order to handle forward declarations of functions (for now only tested at the program level) traversing de program node is done as a two-step process.
Duing the first step only variable and function declarations and definitions are being traversed.
During the second step the body of the functions is traversed.
Technically this is implemented as a boolean flag (registerOnly) in the INFO structure. This solution should be able to handle the localfunctions as well, when the flag is set appropriate in the CAlocalfundef function.

=== SYMBOL TABLE DISTANCE AND OFFSET ===
For fundefs only the offset is determined since the distance is by definition 0.
For funcalls the distance is determined and the offset is taken from its fundef.
For vardefs only the offset is determined since the distance is by definition 0.
For IDs the distance is determined and the offset is taken from its vardef.

=== PRINTING (GLOBAL) VARDEF/VARDEC ===
Beacuse all forms of variabel declaration/definition are moddeled using a single AST node there is no way of knowing what kind of variabel it is any more. This knowledge is need during printing. Parameter definitions don't need a semicolon and next line while vardec, and the global vardeX do  need it.
A nice solution would be to have a vardef that has two sons, a vardec (which only holds the typeinfo, name and offset) and an expression. A param is then just a vardec. When implented correctly the PRTvardef takes care of the semicolon and nextline while the vardec only prints type and name info. 