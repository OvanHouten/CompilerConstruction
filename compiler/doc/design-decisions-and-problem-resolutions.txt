=== SHIFT/REDUCE PROBLEM ===
After adding some rules to the civic.y file it turned out that we had some shift/reduce errors.

Here are two actual lines from the Bison verbose output

   11 unexpr: unop expr .
   12 binexpr: expr . binop expr
   
The shift/reduce errors where caused by the following rule

expr: unexpr
    | binexpr
    ;
    
The two mentioned rules 'unexpr' and 'binexpr' are the names of a rule for unary expressions and for binary expressions repectivly.

This was fixed by combining the two rules into a single slightly more verbose rule, see below for a small portion of the actual solution.

expr: BRACKET_L expr BRACKET_R { $$ = $2; }
    | NOT expr          { $$ = TBmakeUnop( UO_not, $2); }
    | MINUS expr        { $$ = TBmakeUnop( UO_neg, $2); }
    | expr MINUS expr   { $$ = TBmakeBinop( BO_sub, $1, $3); }
    | expr PLUS expr    { $$ = TBmakeBinop( BO_add, $1, $3); }
    | expr STAR expr    { $$ = TBmakeBinop( BO_mul, $1, $3); }

Combined with left and right accosiativity rules for the operators it works as expected.


=== DO-WHILE vs WHILE ===
Currently we have two different AST nodes for the 'while' and the 'do-while' loop. These can easily be combined into a single 'while' node with an extra attribute indicating pre or post condition check in order to distinguish the two.

=== FOR loop vs WHILE loops ===
We can try to combine all the loops into a single AST node. For now we have not implemented this. Mainly because the differences between a for loop and the (do-)while loops.

=== CLEANER GRAMMER ===
We have rebuild the grammar file from scratch. Our grammar was very verbose. After rebuilding it is much move concise and clean. 

=== DANGLING ELSE PROBLEM ===
Introduced a 'bogus' token THEN
%nonassoc THEN
%nonassoc ELSE
And added '%prec THEN' to our grammar rule that handles the if-only case.

=== GIT BRANCHES ===
We have four branches
- master: for the core development
- LocalFunction: for local function related development
- Array: for single and multi dimensional arrays (we opted for developing multi dimensional arrays, it can always be downgraded to single dimensional array if we run out of time)
- Combined: an integration branch for integration of the other three branches (and whish should contain our compiler at the and of the course) 

=== TEST SUITE ===
After integrating the provided test suite we found some bugs in our grammar, for example the dangling-else problem. Within each branch the appropriate tests have been added.
Before every commit we should doe a 'make clean && make check' to ensure we only commit we behaving code.

=== HANDLING FORWARD FUNCTION DECLARATIONS ===
This is handled during the traversal. Function names are registered when before the the next (local)defs node is being travered. Only when the last function name has been registered the functionbody is traversed.

=== SYMBOL TABLE IMPLEMENTATION ===
After long consideration and discussion we opted for linking every ID node (funcall or usage of a variable) to the ID node where the function or the variable was declared.
While implementiting the scope check however it turned out to be a bad decision. Our original implementation stored the fundec of fundef node in the symboltable. That meant that we had to check for the exact node type in order to use the proper marco (FUNDEF_ID or FUNDEC_ID for example) before we could get the information from the node that we wanted. The milestone document mentioned the usage of a single AST node for FUNDEC's and FUNDEF's as a solution for that problem. Since exactly the same was mentioned during the lab when the AST from the course was presented using a single AST node for both FUNDEF and FUNDEC.

=== SYMBOL TABLE DISTANCE AND OFFSET ===
For fundefs only the offset is determined since the distance is by definition 0.
For funcalls the distance is determined and the offset is taken from its fundef.
For vardefs only the offset is determined since the distance is by definition 0.
For IDs the distance is determined and the offset is taken from its vardef.

=== COMBINING VARDEF, GLOBALDEC, GLOBALDEF, PARAM NODES ===
What seemed like a good decision for the FUNDEF and FUNDEC nodes also applies to all forms of variabel declarations, wheter it be global, local or parameter declarations. So at first we switched to using a single VARDEF node that is capable of handling all the variation.

=== PRINTING (GLOBAL) VARDEF/VARDEC ===
Beacuse all forms of variable declaration/definition are moddeled using a single AST node there is no way of knowing what kind of variable it is any more. This knowledge is need during printing. Parameter definitions don't need a semicolon and next line while vardec, and the global vardeX do  need it.
A nice solution would be to have a vardef that has two sons, a vardec (which only holds the typeinfo, name and offset) and an expression. A param is then just a vardec. When implented correctly the PRTvardef takes care of the semicolon and nextline while the vardec only prints type and name info. 

=== TRANSFORM FOR-LOOP VARIABLE ===
There is no real need for renaming the name of the var-loop variable when it is moved to the vardecs section of the enclosing function. It is not needed because the offset within the symbol table will be unique. Since we have the offset available since the context analysis phase any duplicate in variable naming has been signaled. Variables can be identified by their offset, so introducing duplicate names is no problem anymore.

=== NEED TO KEEP DISTANCE ===
Is there realy a need keep the distance for all the symbols? Keeping track of the offset seems logical when taking into account that the targetlanguage is for a stack based VM. So for every variable it is needed to know the relative distance from the top of the stack.